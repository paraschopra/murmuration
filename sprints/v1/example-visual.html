<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>mindscape</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #fff;
    color: #000;
    font-family: 'Courier New', monospace;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
  }
  canvas { display: none; }
  #stage {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
  }
  #ascii {
    white-space: pre;
    font-size: 11px;
    line-height: 1.15;
    letter-spacing: 1px;
    font-weight: bold;
    position: relative;
    z-index: 2;
  }
  #label {
    position: fixed;
    bottom: 18px;
    left: 0; right: 0;
    text-align: center;
    font-size: 10px;
    letter-spacing: 4px;
    opacity: 0.35;
    font-family: 'Courier New', monospace;
  }
  #glitch-layer {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 10;
  }
  .g-line {
    position: absolute;
    left: 0; right: 0;
    height: 1px;
    background: #000;
    opacity: 0;
  }
  #thought {
    position: fixed;
    top: 16px;
    left: 0; right: 0;
    text-align: center;
    font-size: 10px;
    letter-spacing: 2px;
    font-family: 'Courier New', monospace;
    opacity: 0;
    transition: opacity 0.8s;
  }
</style>
</head>
<body>
<div id="stage">
  <div id="ascii"></div>
</div>
<div id="glitch-layer">
  <div class="g-line" id="gl1"></div>
  <div class="g-line" id="gl2"></div>
</div>
<div id="thought"></div>
<div id="label">ORGANISM · METHOD · EMERGENCE</div>

<script>
const W = 72, H = 38;
const grid = () => Array.from({length:H}, () => new Array(W).fill(' '));
let t = 0;
let phase = 0; // 0=life, 1=method, 2=emergence
let phaseT = 0;
const PHASE_DUR = 420;

const thoughts = [
  ["selection pressure", "mutation", "fitness landscape", "deep time"],
  ["hypothesis", "falsify", "iterate", "observe"],
  ["emergence", "alignment", "unknown territory", "becoming"]
];

function noise(x, y, t) {
  return Math.sin(x*0.3+t*0.05)*Math.cos(y*0.25-t*0.03)+
         Math.sin((x+y)*0.2+t*0.07)*0.5;
}

// --- PHASE 0: evolving cellular automata + tree of life ---
let cells = null;
let nextCells = null;
function initLife() {
  cells = Array.from({length:H}, (_,y) =>
    Array.from({length:W}, (_,x) =>
      (Math.random() < 0.28) ? 1 : 0));
  nextCells = grid().map(r => r.map(()=>0));
}

function stepLife() {
  for(let y=0;y<H;y++) for(let x=0;x<W;x++) {
    let n=0;
    for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) {
      if(dx===0&&dy===0) continue;
      n += cells[(y+dy+H)%H][(x+dx+W)%W];
    }
    const c = cells[y][x];
    nextCells[y][x] = (c&&(n===2||n===3))||(!c&&n===3)?1:0;
  }
  [cells, nextCells] = [nextCells, cells];
}

const ALIVE = ['.','·','░','▒','▓','█','*','+','x','o'];
function renderLife(g) {
  stepLife();
  // overlay branching tree
  const branch = (x,y,angle,len,depth) => {
    if(depth<0||len<1) return;
    const nx = Math.round(x+Math.cos(angle)*len);
    const ny = Math.round(y+Math.sin(angle)*len);
    for(let i=0;i<len;i++) {
      const bx = Math.round(x+Math.cos(angle)*i);
      const by = Math.round(y+Math.sin(angle)*i);
      if(bx>=0&&bx<W&&by>=0&&by<H) g[by][bx]='|';
    }
    if(nx>=0&&nx<W&&ny>=0&&ny<H) g[ny][nx]='*';
    branch(nx,ny,angle-0.5,len*0.65,depth-1);
    branch(nx,ny,angle+0.45,len*0.65,depth-1);
  };
  branch(W/2|0, H-1, -Math.PI/2, 8, 4);

  for(let y=0;y<H;y++) for(let x=0;x<W;x++) {
    if(g[y][x]===' ' && cells[y][x]) {
      const n2 = noise(x,y,t);
      const idx = Math.floor(((n2+1)/2)*ALIVE.length);
      g[y][x] = ALIVE[Math.max(0,Math.min(ALIVE.length-1,idx))];
    }
  }
}

// --- PHASE 1: scientific method spiral + data scatter ---
function renderMethod(g) {
  const cx = W/2, cy = H/2;
  // spiral of hypothesis
  for(let i=0;i<600;i++) {
    const a = i*0.12 + t*0.04;
    const r = i*0.055 + 0.5;
    const x = Math.round(cx + Math.cos(a)*r);
    const y = Math.round(cy + Math.sin(a)*r*0.45);
    if(x>=0&&x<W&&y>=0&&y<H) {
      const chars = ['?','!','→','∴','≈','∞','⊕','+'];
      g[y][x] = chars[i%chars.length];
    }
  }
  // scatter points like data
  for(let i=0;i<40;i++) {
    const sx = Math.round((Math.sin(i*1.3+t*0.02)*0.45+0.5)*W);
    const sy = Math.round((Math.cos(i*1.7+t*0.015)*0.4+0.5)*H);
    if(sx>=0&&sx<W&&sy>=0&&sy<H) g[sy][sx]='×';
  }
  // pulsing center
  const pulse = Math.sin(t*0.15);
  const r2 = Math.round(2+pulse*1.5);
  for(let a=0;a<16;a++) {
    const aa = a/16*Math.PI*2;
    const px = Math.round(cx+Math.cos(aa)*r2);
    const py = Math.round(cy+Math.sin(aa)*r2*0.5);
    if(px>=0&&px<W&&py>=0&&py<H) g[py][px]='O';
  }
  g[cy|0][cx|0] = '@';
}

// --- PHASE 2: emergence / AI glitch lattice ---
function renderEmergence(g) {
  // lattice base
  for(let y=0;y<H;y++) for(let x=0;x<W;x++) {
    if(x%6===0||y%4===0) g[y][x]='·';
  }
  // wave interference
  for(let y=0;y<H;y++) for(let x=0;x<W;x++) {
    const d1 = Math.sqrt((x-W*0.3)**2+(y-H*0.5)**2);
    const d2 = Math.sqrt((x-W*0.7)**2+(y-H*0.5)**2);
    const wave = Math.sin(d1*0.6-t*0.18)+Math.sin(d2*0.6-t*0.12);
    if(wave > 1.3) g[y][x]='█';
    else if(wave > 0.7) g[y][x]='▓';
    else if(wave > 0.1) g[y][x]='░';
  }
  // glitch horizontal strips
  const gly = Math.floor(((Math.sin(t*0.11)+1)/2)*H);
  for(let x=0;x<W;x++) {
    const shift = Math.round(Math.sin(x*0.3+t*0.2)*3);
    const srcX = (x+shift+W)%W;
    if(gly>=0&&gly<H) g[gly][srcX] = '▒';
  }
  // neural sparks
  for(let i=0;i<30;i++) {
    const ax = (Math.sin(i*2.1+t*0.09)*0.45+0.5)*W|0;
    const ay = (Math.cos(i*1.8+t*0.07)*0.4+0.5)*H|0;
    const bx = (Math.sin(i*2.1+1.5+t*0.06)*0.45+0.5)*W|0;
    const by = (Math.cos(i*1.8+1.2+t*0.08)*0.4+0.5)*H|0;
    // draw line
    const steps = Math.max(Math.abs(bx-ax),Math.abs(by-ay));
    for(let s=0;s<=steps;s++) {
      const lx = Math.round(ax+(bx-ax)*s/steps);
      const ly = Math.round(ay+(by-ay)*s/steps);
      if(lx>=0&&lx<W&&ly>=0&&ly<H&&g[ly][lx]===' ') g[ly][lx]='-';
    }
  }
}

// border decoration
function addBorder(g) {
  const bchars = ['┌','─','┐','│','└','┘'];
  for(let x=0;x<W;x++) { g[0][x]='─'; g[H-1][x]='─'; }
  for(let y=0;y<H;y++) { g[y][0]='│'; g[y][W-1]='│'; }
  g[0][0]='┌'; g[0][W-1]='┐'; g[H-1][0]='└'; g[H-1][W-1]='┘';
}

// transition blend
function blend(g0, g1, alpha) {
  const g = grid();
  for(let y=0;y<H;y++) for(let x=0;x<W;x++) {
    g[y][x] = Math.random() < alpha ? g1[y][x] : g0[y][x];
  }
  return g;
}

const el = document.getElementById('ascii');
const thoughtEl = document.getElementById('thought');
let thoughtIdx = 0;
let thoughtPhase = 0;

function showThought() {
  const pool = thoughts[phase];
  const word = pool[thoughtIdx % pool.length];
  thoughtEl.textContent = word;
  thoughtEl.style.opacity = '0.5';
  setTimeout(() => { thoughtEl.style.opacity = '0'; }, 2200);
  thoughtIdx++;
}

// glitch lines
const gl1 = document.getElementById('gl1');
const gl2 = document.getElementById('gl2');
function triggerGlitch() {
  const y1 = Math.random()*100;
  const y2 = Math.random()*100;
  gl1.style.top = y1+'%'; gl1.style.opacity = '0.15';
  gl2.style.top = y2+'%'; gl2.style.opacity = '0.1';
  setTimeout(()=>{ gl1.style.opacity='0'; gl2.style.opacity='0'; }, 80);
}

initLife();
setInterval(showThought, 3500);
setInterval(triggerGlitch, 1200);

function render() {
  const g = grid();
  const TRANS = 60; // transition frames

  if(phase===0) {
    renderLife(g);
  } else if(phase===1) {
    if(phaseT < TRANS) {
      const g0 = grid(); renderLife(g0);
      const g1 = grid(); renderMethod(g1);
      const blended = blend(g0,g1,phaseT/TRANS);
      for(let y=0;y<H;y++) for(let x=0;x<W;x++) g[y][x]=blended[y][x];
    } else {
      renderMethod(g);
    }
  } else {
    if(phaseT < TRANS) {
      const g0 = grid(); renderMethod(g0);
      const g1 = grid(); renderEmergence(g1);
      const blended = blend(g0,g1,phaseT/TRANS);
      for(let y=0;y<H;y++) for(let x=0;x<W;x++) g[y][x]=blended[y][x];
    } else {
      renderEmergence(g);
    }
  }

  addBorder(g);
  el.textContent = g.map(r=>r.join('')).join('\n');

  t++;
  phaseT++;
  if(phaseT >= PHASE_DUR) {
    phase = (phase+1)%3;
    phaseT = 0;
    thoughtIdx = 0;
    if(phase===0) initLife();
  }

  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
